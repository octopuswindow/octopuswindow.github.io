<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #canvas {
            border: solid lightseagreen 4px;
            }
    </style>
</head>

<body>
    <canvas id="canvas" width="600" height="600"></canvas>
    <script>
        let canvas = document.querySelector('#canvas');
        let ctx = canvas.getContext('2d');
        ctx.fillStyle = 'lightseagreen';

        // bounce sfx
        let bounce=new Audio("bounce.mp3");
        function playbounce() {
            let a=bounce.cloneNode();
            a.play();
        };

        // eventst
        let left = null;
        let right = null;

        window.addEventListener('keydown', function (e) {
            if (e.code === "ArrowLeft") {
                left = true;
            }
            else if (e.code === "ArrowRight") {
                right = true;
            }
            else if (e.code === 'Space') {
                pause = !pause;
            }
        });

        window.addEventListener('keyup', function (e) {
            if (e.code === "ArrowLeft") {
                left = false;
            }
            else if (e.code === "ArrowRight") {
                right = false;
            }
        });

        function collisionOnEvery(circle, rect) {
            console.log();
            if (Math.sqrt((((rect.x - circle.x) * (rect.x - circle.x)) + ((rect.y - circle.y) * (rect.y - circle.y)))) < circle.r) { // top left vertex
                return true;
            } else if (Math.sqrt((((rect.x + rect.w - circle.x) * (rect.x + rect.w - circle.x)) + ((rect.y - circle.y) * (rect.y - circle.y)))) < circle.r) { // top right vertex
                return true;
            } else if (Math.sqrt((((rect.x + rect.w - circle.x) * (rect.x + rect.w - circle.x)) + ((rect.y + rect.h - circle.y) * (rect.y + rect.h - circle.y)))) < circle.r) { // bottom right vertex
                return true;
            } else if (Math.sqrt((((rect.x - circle.x) * (rect.x - circle.x)) + ((rect.y + rect.h - circle.y) * (rect.y + rect.h - circle.y)))) < circle.r) { // bottom left vertex
                return true;
            } else {
                return circle.x >= rect.x // left edge
                    && circle.x <= rect.x + rect.w // right edge
                    && circle.y + circle.r >= rect.y // hit on top
                    && circle.x >= rect.x // left edge for bottom
                    && circle.x <= rect.x + rect.w // right edge for bottom
                    && circle.y - circle.r <= rect.y + rect.h // hit on bottom
                    || circle.y >= rect.y // top edge for left
                    && circle.y <= rect.y + rect.h // bottom edge for left
                    && circle.x + circle.r >= rect.x // hit on left
                    && circle.y >= rect.y // top edge for right
                    && circle.y <= rect.y + rect.h // bottom edge for right
                    && circle.x - circle.r < rect.x + rect.w; // hit on right
            }
        }

        function collisionOnTopBottom(circle, rect) {
            return circle.x >= rect.x
                && circle.x <= rect.x + rect.w
                && circle.y + circle.r >= rect.y
                && circle.y - circle.r <= rect.y + rect.h
                || Math.sqrt((((rect.x - circle.x) * (rect.x - circle.x)) + ((rect.y - circle.y) * (rect.y - circle.y)))) < circle.r
                || Math.sqrt((((rect.x + rect.w - circle.x) * (rect.x + rect.w - circle.x)) + ((rect.y + rect.h - circle.y) * (rect.y + rect.h - circle.y)))) < circle.r;
        }
        function collisionOnLeftRight(circle, rect) {
            return circle.y >= rect.y
                && circle.y <= rect.y + rect.h
                && circle.x + circle.r >= rect.x
                && circle.x - circle.r <= rect.x + rect.w
                || Math.sqrt((((rect.x + rect.w - circle.x) * (rect.x + rect.w - circle.x)) + ((rect.y - circle.y) * (rect.y - circle.y)))) < circle.r
                || Math.sqrt((((rect.x - circle.x) * (rect.x - circle.x)) + ((rect.y + rect.h - circle.y) * (rect.y + rect.h - circle.y)))) < circle.r;
        }
        //reformat code: shift-alt-f (win) shift option f (mac)

        block = {
            x: 200,
            y: 100,
            w: 80,
            h: 20,
            exist: true,
            draw: function () {
                if (!this.exist) { return };
                ctx.beginPath();
                ctx.fillStyle = "lightseagreen";
                ctx.rect(this.x, this.y, this.w, this.h);
                ctx.fill();
            },
            update: function () {
                if (collisionOnTopBottom(ball, this)) {
                    if (this.exist == true) {
                        ball.vy = ball.vy * -1;
                        this.exist = false
                        score += 10;
                        ball.update();
                    }
                }
                if (collisionOnLeftRight(ball, this)) {
                    if (this.exist == true) {
                        ball.vx = ball.vx * -1;
                        this.exist = false
                        score += 10;
                        ball.update();
                    }
                }
            }
        }

        // 3,10
        let blocks = [];
        function createBlocks(rows, cols) {
            blocks = [];
            for (let r = 0; r < rows; r++) {
                let newRow = [];
                for (let c = 0; c < cols; c++) {
                    let obj = { ...block };
                    /*
                    obj.w = (canvas.width / cols) - 15;
                    obj.x = ((canvas.width / cols) * c) + 0;
                    obj.y = (r * 40) + 20;
                    obj.h = 20
                    */
                    obj.x = c * (obj.w + 30) + 50;
                    obj.y = r * (obj.h + 20) + 50;
                    //obj.w=;
                    //obj.h=;


                    newRow.push(obj);

                }
                blocks.push(...newRow);
                console.log(blocks);
            }
        }
        console.log(blocks);


        let paddle = {
            x: canvas.width / 2 - 80,
            y: canvas.height - 20,
            w: 160,
            h: 20,
            vx: 5,
            draw: function () {
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.w, this.h);
                ctx.fillStyle = 'black';
                ctx.fill();
            },
            update: function () {
                if (left === true && this.x > 0) {
                    this.x -= this.vx;
                }
                if (right === true && this.x < canvas.width - this.w) {
                    this.x += this.vx;
                }
            }
        }

        paddle.draw();

        function doTopCollision(ball, rect) {
            return ball.y + ball.r > rect.y && ball.x >= rect.x && ball.x <= rect.x + rect.w;
        };
        //ball
        let maxAngle = 160;
        let minAngle = 20;

        let ball = {
            x: canvas.width / 2,
            y: canvas.height - 15 - paddle.h,
            r: 15,
            vx: 5,
            vy: -2,
            draw: function () {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fillStyle = 'blue';
                ctx.fill();
            },
            update: function () {





                //this.y+this.r>paddle.y && this.x>=paddle.x && this.x<=paddle.x+paddle.w
                if (collisionOnEvery(this, paddle)) {
                    console.log('ball hit paddle');

                    let hitX = ball.x - paddle.x;
                    //console.log(hitX);
                    let angle = maxAngle - Math.floor((maxAngle - minAngle) / paddle.w * hitX);
                    //console.log(angle);
                    let energy = (this.vx ** 2 + this.vy ** 2) ** 0.5;
                    //console.log(energy);
                    this.vx = energy * Math.cos(angle * Math.PI / 180);
                    this.vy = -energy * Math.sin(angle * Math.PI / 180);
                    //console.log(this.vx,this.vy);
                    playbounce();


                    //this. vy*=-1;
                }
                /*
                for (item in blocks) {
                    if (blocks[item]["exist"] === true) {
                    if (ball.x >= blocks[item].x
                        && ball.x <= blocks[item].x + blocks[item].w
                        && ball.y + ball.r >= blocks[item].y
                        && ball.y - ball.r <= blocks[item].y + blocks[item].h
                        || Math.sqrt((((blocks[item].x - ball.x) * (blocks[item].x - ball.x)) + ((blocks[item].y - ball.y) * (blocks[item].y - ball.y)))) < ball.r
                        || Math.sqrt((((blocks[item].x + blocks[item].w - ball.x) * (blocks[item].x + blocks[item].w - ball.x)) + ((blocks[item].y + blocks[item].h - ball.y) * (blocks[item].y + blocks[item].h - ball.y)))) < ball.r) {
                            this.vy = this.vy * -1
                    }
                }
                }
                */


                if (this.x < this.r) {
                    this.vx = Math.abs(this.vx);
                    playbounce();
                }
                if (this.x > canvas.width - this.r) {
                    this.vx = Math.abs(this.vx) * -1;
                    playbounce();
                }
                if (this.y < 15) {
                    this.vy = Math.abs(this.vy);
                    playbounce();
                }

                this.x += this.vx;
                this.y += this.vy;
            }
        }
        //ball.update();
        ball.draw();

        // write text
        function drawText(text, x, y, color) {
            ctx.beginPath();
            ctx.font = "20px monospace";
            ctx.fillStyle = color;
            ctx.fillText(text, x, y);
        }
        // background
        let bg=new Image();
        bg.src="breakout_bg.avif";

        let score = 0;

        createBlocks(3, 10);
        block.exist = false;
        let pause = false;
        //game loop
        function loop() {
            requestAnimationFrame(loop);
            
            if (pause) return;
            //clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(bg, 0 , 0);

            //draw
            block.draw();
            //console.log("what");
            for (item in blocks) {
                blocks[item].draw();
            }
            paddle.draw();
            ball.draw();
            drawText(score ,10,20, "lightseagreen")

            //update

            block.update();
            for (item in blocks) {
                blocks[item].update();
                if (blocks[item].exist == false) {
                    blocks.splice(item, 1);
                    playbounce();
                    //console.log("fsd");
                    
                }
            }
            ball.update();
            paddle.update();
            




        }

        loop();

        //paddle
        ///ctx.fillRect(250,580,100,20);
        //ball
        ///ctx.beginPath();
        ///ctx.arc(300,570,10,0,Math.PI*2);
        ///ctx.fill();

    </script>
</body>

</html>